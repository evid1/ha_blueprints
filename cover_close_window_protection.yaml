blueprint:
  name: Rollo-Steuerung Pro (v7)
  description: >
    Schließt Rollos nach Dämmerung + Offset. 
    Interrupt-sicher: Fensterbewegungen unterbrechen das Warten nicht permanent.
  domain: automation
  input:
    target_cover:
      name: Rollo
      selector:
        entity:
          domain: cover
    window_sensor:
      name: Fenster- oder Türsensor
      selector:
        entity:
          domain: binary_sensor
          device_class: [window, door]
    sunset_offset_mins:
      name: Verzögerung (Minuten)
      default: 30
      selector:
        number:
          min: -120
          max: 300
          unit_of_measurement: min
          mode: box
    notify_device:
      name: Benachrichtigungs-Dienst (Optional)
      default: []
      selector:
        action: {}
    enable_auto_open:
      name: Automatisch öffnen
      default: false
      selector:
        boolean: {}
    open_position_pct:
      name: Öffnungsgrad
      default: 100
      selector:
        number:
          min: 0
          max: 100
          unit_of_measurement: "%"
          mode: slider

mode: restart

variables:
  offset_mins: !input sunset_offset_mins
  # Berechnet den Zielzeitpunkt absolut (heutige Dämmerung + Offset)
  target_time: >
    {% set next_dusk = states('sensor.sun_next_dusk') | as_datetime %}
    {% set dusk = next_dusk - timedelta(days=1) if next_dusk > now() + timedelta(hours=12) else next_dusk %}
    {{ dusk + timedelta(minutes=offset_mins | int) }}

trigger:
  - platform: time
    at: sensor.sun_next_dusk
    id: "zeit_event"
  - platform: state
    entity_id: !input window_sensor
    id: "sensor_event"

action:
  - choose:
      # FALL 1: FENSTER WIRD GEÖFFNET
      - conditions:
          - condition: trigger
            id: "sensor_event"
          - condition: state
            entity_id: !input window_sensor
            state: "on"
          - condition: template
            value_template: !input enable_auto_open
          - condition: template
            value_template: "{{ now() >= target_time | as_datetime }}"
        sequence:
          - service: cover.set_cover_position
            target:
              entity_id: !input target_cover
            data:
              position: !input open_position_pct

      # FALL 2: SCHLIESS-LOGIK (Zeit erreicht ODER Fenster zu)
      - conditions:
          - condition: template
            value_template: "{{ now() >= (target_time | as_datetime - timedelta(minutes=1)) }}"
        sequence:
          # Schritt A: Warte bis der exakte Offset-Zeitpunkt erreicht ist
          - wait_template: "{{ now() >= target_time | as_datetime }}"
          
          # Schritt B: Wenn Fenster offen, schicke Nachricht (nur einmalig beim Zeit-Event)
          - if:
              - condition: state
                entity_id: !input window_sensor
                state: "on"
            then:
              - choose: []
                default: !input notify_device
          
          # Schritt C: Warte bis das Fenster geschlossen wird (kein Timeout)
          - wait_for_trigger:
              - platform: state
                entity_id: !input window_sensor
                to: "off"
            # Falls es schon zu ist, geht es sofort weiter
            timeout: "00:00:01" 
            continue_on_timeout: true

          # Schritt D: Finaler Check und Schließen
          - if:
              - condition: state
                entity_id: !input window_sensor
                state: "off"
            then:
              - service: cover.close_cover
                target:
                  entity_id: !input target_cover